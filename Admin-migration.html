<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Menuva — Admin Migration</title>
  <style>
    :root{font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;padding:0;margin:0}
    body{padding:20px;background:#f5f7fb;color:#0f172a}
    .card{background:#fff;padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(12,20,40,0.06);max-width:980px;margin:12px auto}
    textarea, input, select{width:100%;box-sizing:border-box;padding:8px;margin:6px 0;border:1px solid #e6eef8;border-radius:8px}
    button{padding:10px 14px;border-radius:10px;border:0;background:#0369a1;color:#fff;cursor:pointer}
    pre{background:#0b1220;color:#dbeafe;padding:12px;border-radius:8px;overflow:auto}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .muted{color:#64748b;font-size:13px}
    .danger{background:#ef4444}
  </style>
</head>
<body>
  <div class="card">
    <h2>Orderine — Admin Migration Script</h2>
    <p class="muted">Isi <code>SUPABASE_URL</code> dan <code>SUPABASE_KEY</code> (service role atau anon). <strong>PERINGATAN:</strong> Jangan letakkan service role key di client yang publik — idealnya jalankan ini di server atau gunakan environment secrets.</p>

    <div class="row">
      <div>
        <label>SUPABASE_URL</label>
        <input id="supabaseUrl" placeholder="https://orderine.github.io/Orderine-Digital/Admin-migration.html" />
      </div>
      <div>
        <label>SUPABASE_KEY (service role / anon)</label>
        <input id="supabaseKey" placeholder="sb_publishable_L69H0-PapAm3jMWrTyYayQ_4kOd2MMD" />
      </div>
    </div>

    <label>Bucket name</label>
    <input id="bucketName" placeholder="public or your-bucket" />

    <label>Table name</label>
    <input id="tableName" placeholder="Orderine" />

    <label>Column that holds Base64 data (comma-separated if multiple)</label>
    <input id="base64Columns" placeholder="logo,background,menu_image" />

    <label>Column to update with new storage URL (if different; comma order matches base64 columns)</label>
    <input id="urlColumns" placeholder="logo_url,background_url,menu_image_url" />

    <div style="margin-top:8px;display:flex;gap:8px">
      <button id="btnConnect">Init & Test Connection</button>
      <button id="btnStart" style="background:#059669">Start Migration</button>
      <button id="btnCleanIDB" class="danger">Bersih IndexedDB</button>
    </div>

    <h3>Log</h3>
    <pre id="log" style="height:240px"></pre>
  </div>

<script type="module">
  import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

  let supabase = null;

  const el = id => document.getElementById(id);
  const logEl = el('log');
  const appendLog = (s) => { logEl.textContent += `${new Date().toISOString()} - ${s}\n`; logEl.scrollTop = logEl.scrollHeight; }

  function safeFileName(prefix, id, col){
    const clean = String(id).replace(/[^a-z0-9\-_.]/gi,'_');
    return `${prefix}/${col}/${clean}_${Date.now()}`;
  }

  // ------ Supabase init & test ------
  document.getElementById('btnConnect').addEventListener('click', async ()=>{
    const url = el('supabaseUrl').value.trim();
    const key = el('supabaseKey').value.trim();
    if(!url||!key){ appendLog('ERROR: SUPABASE_URL or KEY kosong'); return }
    supabase = createClient(url, key, { auth: { persistSession: false } });
    appendLog('Client dibuat — mengecek koneksi...');
    // Simple test: list buckets
    try{
      const { data, error } = await supabase.storage.listBuckets ? await supabase.storage.listBuckets() : await supabase.rpc('version')
      appendLog('Koneksi berhasil (storage/listBuckets ok)');
    }catch(e){ appendLog('Koneksi test gagal: '+(e.message||e)); }
  });

  // ------ Helpers: convert base64 to Blob ------
  function base64ToBlob(b64Data, contentType='application/octet-stream'){
    const sliceSize = 512;
    const byteCharacters = atob(b64Data.replace(/^data:[^;]+;base64,/, ''));
    const byteArrays = [];
    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
      const slice = byteCharacters.slice(offset, offset + sliceSize);
      const byteNumbers = new Array(slice.length);
      for (let i = 0; i < slice.length; i++) byteNumbers[i] = slice.charCodeAt(i);
      const byteArray = new Uint8Array(byteNumbers);
      byteArrays.push(byteArray);
    }
    return new Blob(byteArrays, { type: contentType });
  }

  // attempt to detect mime from data URI
  function detectMime(base64str){
    const m = base64str.match(/^data:([^;]+);base64,/);
    return m? m[1] : 'application/octet-stream';
  }

  // ------ Upload single base64 to bucket ------
  async function uploadBase64ToStorage(base64str, bucket, path){
    if(!supabase) throw new Error('Supabase client belum di-init');
    // If value already appears to be a URL, skip
    if(typeof base64str !== 'string') return null;
    if(base64str.startsWith('http://') || base64str.startsWith('https://')) return base64str;

    const contentType = detectMime(base64str);
    const blob = base64ToBlob(base64str, contentType);

    appendLog(`Uploading to ${bucket}/${path} (${blob.size} bytes)`);
    // supabase-js storage.from(bucket).upload(path, blob)
    const { data, error } = await supabase.storage.from(bucket).upload(path, blob, { upsert: false });
    if(error){
      // If file exists, try upsert true
      if(error.message && error.message.includes('already exists')){
        appendLog('File sudah ada, mencoba overwrite (upsert)');
        const { data: d2, error: e2 } = await supabase.storage.from(bucket).upload(path, blob, { upsert: true });
        if(e2) throw e2; else return d2;
      }
      throw error;
    }
    return data;
  }

  function publicUrlFor(bucket, path){
    // Using public bucket, simple public URL. If bucket is private, you must generate signed URLs via server.
    const base = el('supabaseUrl').value.replace(/\/$/,'');
    return `${base}/storage/v1/object/public/${bucket}/${encodeURIComponent(path)}`;
  }

  // ------ Migration flow for one row ------
  async function migrateRow(table, id, base64Cols, urlCols, bucket, prefix='menuva'){
    // fetch row
    const { data: rows, error } = await supabase.from(table).select('*').eq('id', id).limit(1).maybeSingle();
    if(error) throw error;
    if(!rows) { appendLog(`Baris id=${id} tidak ditemukan`); return null }
    const row = rows;

    const updates = {};

    for(let i=0;i<base64Cols.length;i++){
      const col = base64Cols[i];
      const urlCol = (urlCols[i]||col+'_url');
      const value = row[col];
      if(!value){ appendLog(`id=${id} kolom ${col} kosong — skip`); continue }
      // skip if already a URL
      if(typeof value === 'string' && (value.startsWith('http://')||value.startsWith('https://'))){ appendLog(`id=${id} ${col} sudah URL, skip`); updates[urlCol]=value; continue }
      const path = safeFileName(prefix, id, col);
      try{
        await uploadBase64ToStorage(value, bucket, path);
        const publicUrl = publicUrlFor(bucket, path);
        updates[urlCol] = publicUrl;
        appendLog(`id=${id} ${col} -> ${publicUrl}`);
      }catch(e){ appendLog(`ERROR upload id=${id} col=${col} : ${e.message||e}`); }
    }

    // update row with new urls
    if(Object.keys(updates).length){
      const { data, error: e } = await supabase.from(table).update(updates).eq('id', id);
      if(e) appendLog('ERROR update row '+(e.message||e)); else appendLog(`id=${id} updated columns: ${Object.keys(updates).join(',')}`);
    }
    return updates;
  }

  // ------ Bulk migrate (iterate all rows) ------
  async function migrateAll(table, base64Cols, urlCols, bucket, prefix='menuva'){
    appendLog('Mulai migrasi semua baris...');
    // paginate to avoid memory spike — 100 per page
    const pageSize = 100;
    let page = 0;
    while(true){
      const from = page * pageSize;
      const to = from + pageSize - 1;
      appendLog(`Fetching rows ${from}..${to}`);
      const { data, error } = await supabase.from(table).select('*').range(from, to);
      if(error){ appendLog('ERROR fetch page: '+(error.message||error)); break }
      if(!data || data.length===0) { appendLog('Selesai: tidak ada lagi baris'); break }
      for(const r of data){
        try{
          await migrateRow(table, r.id, base64Cols, urlCols, bucket, prefix);
        }catch(e){ appendLog('ERROR migrating id='+r.id+' -> '+(e.message||e)); }
      }
      if(data.length < pageSize) { appendLog('Selesai: akhir halaman terakhir.'); break }
      page++;
    }
    appendLog('Bulk migration selesai.');
  }

  // ------ Clean IndexedDB ------
  async function clearIndexedDB(dbName='MenuvaDB'){
    appendLog(`Menghapus IndexedDB: ${dbName}`);
    return new Promise((res, rej)=>{
      const req = indexedDB.deleteDatabase(dbName);
      req.onsuccess = ()=>{ appendLog('IndexedDB dihapus (onsuccess)'); res(true) };
      req.onerror = (e)=>{ appendLog('IndexedDB delete error'); rej(e) };
      req.onblocked = ()=>{ appendLog('Delete blocked — pastikan tab lain tidak membuka DB'); }
    });
  }

  // ------ Realtime subscription example ------
  function startRealtime(table){
    if(!supabase) throw new Error('Supabase client belum di-init');
    appendLog('Membuat langganan realtime untuk table: '+table);
    // supabase-js v2 uses channels
    try{
      const channel = supabase.channel('realtime-'+table)
        .on('postgres_changes', { event: '*', schema: 'public', table }, payload => {
          appendLog(`Realtime event: ${payload.eventType} id=${payload.new?.id || payload.old?.id}`);
        })
        .subscribe();
      appendLog('Subscribed to realtime channel.');
    }catch(e){ appendLog('Realtime subscription error: '+(e.message||e)); }
  }

  // ------ Wire buttons ------
  document.getElementById('btnStart').addEventListener('click', async ()=>{
    try{
      const url = el('supabaseUrl').value.trim();
      const key = el('supabaseKey').value.trim();
      const bucket = el('bucketName').value.trim() || 'public';
      const table = el('tableName').value.trim() || 'menuvaData';
      const base64Cols = el('base64Columns').value.split(',').map(s=>s.trim()).filter(Boolean);
      const urlCols = el('urlColumns').value.split(',').map(s=>s.trim());
      if(!url||!key) { appendLog('ERROR: masukkan supabase URL & key'); return }
      if(!bucket||!table||base64Cols.length===0){ appendLog('ERROR: bucket, table, atau base64 columns kosong'); return }
      // init client
      supabase = createClient(url, key, { auth: { persistSession: false } });
      await migrateAll(table, base64Cols, urlCols, bucket, 'menuva_migration');
    }catch(e){ appendLog('FATAL ERROR: '+(e.message||e)); }
  });

  document.getElementById('btnCleanIDB').addEventListener('click', async ()=>{
    try{ await clearIndexedDB('MenuvaDB'); appendLog('IndexedDB clear triggered'); }catch(e){ appendLog('Error clearing IDB: '+(e.message||e)); }
  });

  // Expose some helpers for dev console
  window._menuva = {
    migrateRow, migrateAll, uploadBase64ToStorage, clearIndexedDB, startRealtime
  };

  appendLog('Admin migration script siap. Masukkan kredensial lalu klik Init & Test Connection.');
</script>
</body>
</html>


